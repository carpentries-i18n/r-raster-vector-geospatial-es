---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 01-raster-structure.md in _episodes_rmd/
title: "Introducción a Datos Ráster en R"
teaching: 40
exercises: 20
questions:
-  "¿Qué son datos Raster?"
-  "¿Cómo trabajo y visualizo datos ráster en R?"
-  "¿Cómo puedo manejar datos ausentes o valores malos en un ráster?"
objectives:
-  "Describir las características fundamentales de un conjunto de datos ráster."
-  "Explorar las características y los metadatos de un ráster usando R."
-  "Importar rásters en R usando el paquete `raster`."
-  "Visualisar un fichero ráster con R usando el paquete `ggplot2`."
-  "Describir la diferencia entre ráster de banda única y múltiple."
keypoints:
- "El formato de fichero GeoTIFF incluye metadaots sobre el ráster." 
- "Para visualizar datos ráster con el paquete `ggplot2`, necesitamos convertirlo a un marco de datos.."
- "R guarda información CRS en el formato Proj4."
- "Ten cuidado cuando manejas rásters con datos ausentes o valores malos.."
source: Rmd
---





> ## Cosas que necesitarás para completar este episodio
>
> Mira la [página principal de la lección]({{ site.baseurl }}) donde encontrarás información detallada sobre el software,
> los datos, y otros requisitos previos que necesitarás para seguir los ejemplos de este episodio.
{: .prereq}

En este episodio, presentaremos los principios fundamentales, los paquetes y
atributos de metadatos/raster que se necesitan para trabajar con datos raster en R. Vamos
a discutir algunos de los elementos centrales de los metadatos que necesitamos comprender para trabajar con
rasters en R, incluyendo CRS y resolución. También exploraremos los valores faltantes y erróneos
de datos almacenados en un raster y cómo R maneja estos elementos.

Continuaremos trabajando con los paquetes `dplyr` y` ggplot2` que se introdujeron
en la lección [Introducción a R para datos geoespaciales] (https://datacarpentry.org/r-intro-geospatial/). Usaremos dos paquetes adicionales en este episodio para trabajar con 
datos ráster: los paquetes `raster` y` rgdal`. Asegurate de tener estos paquetes cargados.


~~~
library(raster)
library(rgdal)
library(ggplot2)
library(dplyr)
~~~
{: .language-r}

> ## Introduce the Data
>
> Si aún no se ha discutido, presenta los conjuntos de datos que se utilizarán en esta
> lección. Una breve introducción al conjunto de datos puede encontrarse en
> [Geospatial workshop homepage](https://datacarpentry.org/geospatial-workshop/#data).
> 
> Para mayor información acerca del conjunto de datos, consulta
la [Geospatial workshop data
page](http://datacarpentry.org/geospatial-workshop/data/).
{: .callout}

## View Raster File Attributes

We will be working with a series of GeoTIFF files in this lesson. The
GeoTIFF format contains a set of embedded tags with metadata about the raster
data. We can use the function `GDALinfo()` to get information about our raster
data before we read that data into R. It is ideal to do this before importing
your data.


~~~
GDALinfo("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")
~~~
{: .language-r}



~~~
rows        1367 
columns     1697 
bands       1 
lower left origin.x        731453 
lower left origin.y        4712471 
res.x       1 
res.y       1 
ysign       -1 
oblique.x   0 
oblique.y   0 
driver      GTiff 
projection  +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
file        data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif 
apparent band summary:
   GDType hasNoDataValue NoDataValue blockSize1 blockSize2
1 Float64           TRUE       -9999          1       1697
apparent band statistics:
    Bmin   Bmax    Bmean      Bsd
1 305.07 416.07 359.8531 17.83169
Metadata:
AREA_OR_POINT=Area 
~~~
{: .output}

If you wish to store this information in R, you can do the following:


~~~
HARV_dsmCrop_info <- capture.output(
  GDALinfo("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")
)
~~~
{: .language-r}

Each line of text that was printed to the console is now stored as an element of
the character vector `HARV_dsmCrop_info`. We will be exploring this data throughout this 
episode. By the end of this episode, you will be able to explain and understand the output above.

## Open a Raster in R

Now that we've previewed the metadata for our GeoTIFF, let's import this
raster dataset into R and explore its metadata more closely. We can use the `raster()` 
function to open a raster in R.

> ## Data Tip - Object names
> To improve code
> readability, file and object names should be used that make it clear what is in
> the file. The data for this episode were collected from Harvard Forest so
> we'll use a naming convention of `datatype_HARV`.
{: .callout}

First we will load our raster file into R and view the data structure.


~~~
DSM_HARV <- 
  raster("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")

DSM_HARV
~~~
{: .language-r}



~~~
class      : RasterLayer 
dimensions : 1367, 1697, 2319799  (nrow, ncol, ncell)
resolution : 1, 1  (x, y)
extent     : 731453, 733150, 4712471, 4713838  (xmin, xmax, ymin, ymax)
crs        : +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
source     : /home/travis/build/datacarpentry/r-raster-vector-geospatial/_episodes_rmd/data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif 
names      : HARV_dsmCrop 
values     : 305.07, 416.07  (min, max)
~~~
{: .output}

The information above includes a report of min and max values, but no other data
range statistics. Similar to other R data structures like vectors and data frame
columns, descriptive statistics for raster data can be retrieved like


~~~
summary(DSM_HARV)
~~~
{: .language-r}



~~~
Warning in .local(object, ...): summary is an estimate based on a sample of 1e+05 cells (4.31% of all cells)
~~~
{: .error}



~~~
        HARV_dsmCrop
Min.        305.5500
1st Qu.     345.6500
Median      359.6450
3rd Qu.     374.2825
Max.        413.9000
NA's          0.0000
~~~
{: .output}

but note the warning - unless you force R to calculate these statistics using
every cell in the raster, it will take a random sample of 100,000 cells and
calculate from that instead. To force calculation on more, or even all values,
you can use the parameter `maxsamp`:


~~~
summary(DSM_HARV, maxsamp = ncell(DSM_HARV))
~~~
{: .language-r}



~~~
        HARV_dsmCrop
Min.          305.07
1st Qu.       345.59
Median        359.67
3rd Qu.       374.28
Max.          416.07
NA's            0.00
~~~
{: .output}

You may not see major differences in summary stats as `maxsamp` increases,
except with very large rasters.

To visualise this data in R using `ggplot2`, we need to convert it to a
dataframe. We learned about dataframes in [an earlier
lesson](https://datacarpentry.org/r-intro-geospatial/04-data-structures-part2/index.html).
The `raster` package has an built-in function for conversion to a plotable dataframe.


~~~
DSM_HARV_df <- as.data.frame(DSM_HARV, xy = TRUE)
~~~
{: .language-r}

Now when we view the structure of our data, we will see a standard
dataframe format.


~~~
str(DSM_HARV_df)
~~~
{: .language-r}



~~~
'data.frame':\t2319799 obs. of  3 variables:
 $ x           : num  731454 731454 731456 731456 731458 ...
 $ y           : num  4713838 4713838 4713838 4713838 4713838 ...
 $ HARV_dsmCrop: num  409 408 407 407 409 ...
~~~
{: .output}

We can use `ggplot()` to plot this data. We will set the color scale to `scale_fill_viridis_c`
which is a color-blindness friendly color scale. We will also use the `coord_quickmap()` function to use an approximate Mercator projection for our plots. This approximation is suitable for small areas that are not too close to the poles. Other coordinate systems are available in ggplot2 if needed, you can learn about them at their help page `?coord_map`.


~~~
ggplot() +
    geom_raster(data = DSM_HARV_df , aes(x = x, y = y, fill = HARV_dsmCrop)) +
    scale_fill_viridis_c() +
    coord_quickmap()
~~~
{: .language-r}

<img src="{{ site.baseurl }}/fig/rmd-01-ggplot-raster-1.png" title="Raster plot with ggplot2 using the viridis color scale" alt="Raster plot with ggplot2 using the viridis color scale" width="612" style="display: block; margin: auto;" />
> ## Plotting Tip
>
> More information about the Viridis palette used above at
> [R Viridis package documentation](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html).
{: .callout}

> ## Plotting Tip
> For faster, simpler plots, you can use the `plot` function from the `raster` package.
> > ## Show plot
> >  Revisa `?plot` para más parámentros para personalizar el gráfico
> > 
> > ~~~
> > plot(DSM_HARV)
> > ~~~
> > {: .language-r}
> > 
> > <img src="{{ site.baseurl }}/fig/rmd-01-unnamed-chunk-5-1.png" title="plot of chunk unnamed-chunk-5" alt="plot of chunk unnamed-chunk-5" width="612" style="display: block; margin: auto;" />
> {: .solution}
{: .callout}

Este mapa muestra la elevación de nuestro sitio de estudio en Harvard Forest. En la leyenda, 
podemos ver que la elevación máxima es ~ 400, pero no podemos decir si 
es 400 pies o 400 metros porque la leyenda no nos muestra las unidades.
 Podemos mirar los metadatos de nuestro objeto para ver cuáles son las unidades. Gran parte
de los metadatos que nos interesan forman parte del CRS [una lección previa](https://datacarpentry.org/organization-geospatial/03-crs).

Now we will see how features of the CRS appear in our data file and what
meanings they have.

### View Raster Coordinate Reference System (CRS) in R
We can view the CRS string associated with our R object using the`crs()`
function.


~~~
crs(DSM_HARV)
~~~
{: .language-r}



~~~
CRS arguments:
 +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
~~~
{: .output}

> ## Challenge
> What units are our data in?
>
> > ## Answers
> > `+units=m` tells us that our data is in meters.
> {: .solution}
{: .challenge}

## Understanding CRS in Proj4 Format
El CRS para nuestros datos nos lo proporciona R en formato `proj4`. Analicemos las
piezas de `proj4` string. El string contiene todos los elementos individuales del CRS 
que R u otro GIS pueden necesitar. Cada elemento se especifica con un signo `+`, 
similar a cómo un archivo `.csv` está delimitado o separado por una `, `. Después
de cada `+` vemos que se define el elemento CRS. Por ejemplo, proyección (`proj =`)
y datum (`datum =`).

### UTM Proj4 String
Our projection string for `DSM_HARV` specifies the UTM projection as follows:

`+proj=utm +zone=18 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0`

* **proj=utm:** the projection is UTM, UTM has several zones.
* **zone=18:** the zone is 18
* **datum=WGS84:** the datum is WGS84 (the datum refers to the  0,0 reference for
the coordinate system used in the projection)
* **units=m:** the units for the coordinates are in meters
* **ellps=WGS84:** the ellipsoid (how the earth's  roundness is calculated) for
the data is WGS84

Note that the zone is unique to the UTM projection. Not all CRSs will have a
zone. Image source: Chrismurf at English Wikipedia, via [Wikimedia Commons](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system#/media/File:Utm-zones-USA.svg) (CC-BY).

![The UTM zones across the continental United States. From: https://upload.wikimedia.org/wikipedia/commons/8/8d/Utm-zones-USA.svg]({{ site.baseurl }}/images/Utm-zones-USA.svg)

## Calculate Raster Min and Max Values

It is useful to know the minimum or maximum values of a raster dataset. In this
case, given we are working with elevation data, these values represent the
min/max elevation range at our site.

Es útil saber los valores mínimos y máximos de un conjunto de datos raster. En este
caso, dado que estamos trabajando con datos de elevación, estos valores representan
el rango min/max de elevación de nuestro sitio. 

Raster statistics are often calculated and embedded in a GeoTIFF for us. We
can view these values:


~~~
minValue(DSM_HARV)
~~~
{: .language-r}



~~~
[1] 305.07
~~~
{: .output}



~~~
maxValue(DSM_HARV)
~~~
{: .language-r}



~~~
[1] 416.07
~~~
{: .output}

> ## Data Tip - Set min and max values
> Si los valores mínimos y máximos no han sido calculados hasta el momento,
> podemos calcularlos usando
> con la función `setMinMax()`.
>
> 
> ~~~
> DSM_HARV <- setMinMax(DSM_HARV)
> ~~~
> {: .language-r}
{: .callout}

Podemos ver que la elevación en nuestro sitio varía entre 305.0700073m y
416.0699768m.

## Raster Bands
The Digital Surface Model object (`DSM_HARV`) that we've been working with is a
single band raster. This means that there is only one dataset stored in the
raster: surface elevation in meters for one time period.

![Multi-band raster image]({{ site.baseurl }}/images/dc-spatial-raster/single_multi_raster.png)

Un conjunto de datos ráster contiene una o más bandas. Podemos usar la función
`raster()` para importar una única banda de un ráster de una o múltiples bandas. Podemos
ver el número de bandas en un ráster usando la función `nlayers()`.


~~~
nlayers(DSM_HARV)
~~~
{: .language-r}



~~~
[1] 1
~~~
{: .output}

However, raster data can also be multi-band, meaning that one raster file
contains data for more than one variable or time period for each cell. By
default the `raster()` function only imports the first band in a raster
regardless of whether it has one or more bands. Jump to a later episode in
this series for information on working with multi-band rasters:
[Work with Multi-band Rasters in R]({{ site.baseurl }}/05-raster-multi-band-in-r/).

## Dealing with Missing Data

Los datos ráster frecuentemente tienen un `NoDataValue` asociado a ellos. Este es un valor
asignado a píxeles donde la información está ausente o no se recolectaron datos. 

Por defecto, la forma de un ráster es siempre rectangular. Entonces, si tenemos un
conjunto de datos que tiene una forma que no es rectangular, algunos píxeles en el borde del ráster
tendrán `NoDataValue`s. Esto sucede a menudo cuando los datos fueron recopilados por un avión
que solo sobrevoló una parte de una región definida.

En la imagen de abajo, los píxeles que son negros tienen "NoDataValue". La cámara
no recopiló datos en estas áreas.

<img src="{{ site.baseurl }}/fig/rmd-01-demonstrate-no-data-black-ggplot-1.png" title="plot of chunk demonstrate-no-data-black-ggplot" alt="plot of chunk demonstrate-no-data-black-ggplot" width="612" style="display: block; margin: auto;" />

En la siguiente imagen, a los bordes negros se les asignó "NoDataValue"s. R no formatea píxeles que contienen un "NoDataValue" especificado. R asigna los datos faltantes con el "NoDataValue" como "NA".

La diferencia aquí se muestra como bordes irregulares en el gráfico, en lugar de espacios negros donde no hay datos.

<img src="{{ site.baseurl }}/fig/rmd-01-demonstrate-no-data-ggplot-1.png" title="plot of chunk demonstrate-no-data-ggplot" alt="plot of chunk demonstrate-no-data-ggplot" width="612" style="display: block; margin: auto;" />

Si tu ráster ya tiene valores `NA` configurados correctamente pero no está seguro de dónde están, puedes trazarlos deliberadamente en un color particular. Esto puede resultar útil al comprobar la cobertura de un conjunto de datos. Por ejemplo, a veces pueden haber datos faltantes donde un sensor no pudo 'ver' sus datos de destino, y es posible que tu desees ubicar esos datos faltantes y completarlos.

To highlight `NA` values in ggplot, alter the `scale_fill_*()` layer to contain a colour instruction for `NA` values, like `scale_fill_viridis_c(na.value = 'deeppink')`

<img src="{{ site.baseurl }}/fig/rmd-01-napink-1.png" title="plot of chunk napink" alt="plot of chunk napink" width="612" style="display: block; margin: auto;" />

El valor que se usa convencionalmente para tomar nota de los datos faltantes (el valor
`NoDataValue`) varía según el tipo de datos ráster. Para rásteres de punto flotante, 
la cifra `-3.4e + 38` es un valor predeterminado común, y para números enteros,` -9999`
es común. Algunas disciplinas tienen convenciones específicas que varían de estos
valores comunes.

En algunos casos, otros valores de `NA` pueden ser más apropiados. Un valor `NA` debe
estar a) fuera del rango de valores válidos y b) un valor que se ajuste al tipo de datos 
en uso. Por ejemplo, si sus datos varían continuamente de -20 a 100, ¡0 no es un valor
aceptable de `NA`! O, para las categorías de 1 a 15, 0 podría estar bien para `NA`, pero 
usar -.000003 te obligará a guardar el GeoTIFF en el disco como un ráster **float**, 
resultando un archivo más grande.

Si tenemos suerte, nuestro archivo GeoTIFF tiene una etiqueta que nos dice qué es el
`NoDataValue`. Si tenemos menos suerte, podemos encontrar esa información en los
metadatos del ráster. Si se almacenó un "NoDataValue" en la etiqueta GeoTIFF, cuando R
abre el ráster, asignará cada instancia del valor a "NA". R ignorará los valores de "NA" 
como se demostró anteriormente.

> ## Challenge
> Utiliza la salida de la función `GDALinfo ()` para averiguar qué `NoDataValue` se utiliza para nuestro conjunto de datos `DSM_HARV`.
>
> > ## Answers
> >
> > 
> > ~~~
> > GDALinfo("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > rows        1367 
> > columns     1697 
> > bands       1 
> > lower left origin.x        731453 
> > lower left origin.y        4712471 
> > res.x       1 
> > res.y       1 
> > ysign       -1 
> > oblique.x   0 
> > oblique.y   0 
> > driver      GTiff 
> > projection  +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
> > file        data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif 
> > apparent band summary:
> >    GDType hasNoDataValue NoDataValue blockSize1 blockSize2
> > 1 Float64           TRUE       -9999          1       1697
> > apparent band statistics:
> >     Bmin   Bmax    Bmean      Bsd
> > 1 305.07 416.07 359.8531 17.83169
> > Metadata:
> > AREA_OR_POINT=Area 
> > ~~~
> > {: .output}
> >
> > `NoDataValue` are encoded as -9999.
> {: .solution}
{: .callout}

## Bad Data Values in Rasters

Los datos malos o incorrectos son diferentes de los `NoDataValue`. Los datos incorrectos son valores que caen fuera del rango posible del conjunto de datos. 

Examples of Bad Data Values:

* The normalized difference vegetation index (NDVI), which is a measure of
greenness, has a valid range of -1 to 1. Any value outside of that range would
be considered a "bad" or miscalculated value.
* Reflectance data in an image will often range from 0-1 or 0-10,000 depending
upon how the data are scaled. Thus a value greater than 1 or greater than 10,000
is likely caused by an error in either data collection or processing.

### Encontrar datos incorrectos
A veces, los metadatos de un ráster nos dirán el rango de valores esperados para un 
ráster. Los valores fuera de este rango son sospechosos y debemos tenerlo en cuenta 
cuando analizamos los datos. A veces, necesitamos usar un poco de sentido común y
conocimiento científico al examinar los datos, tal como lo haríamos con los datos de
 campo para identificar valores cuestionables.

Plotting data with appropriate highlighting can help reveal patterns in bad
values and may suggest a solution. Below, reclassification is used to highlight
elevation values over 400m with a contrasting colour.

<img src="{{ site.baseurl }}/fig/rmd-01-demo-bad-data-highlighting-1.png" title="plot of chunk demo-bad-data-highlighting" alt="plot of chunk demo-bad-data-highlighting" width="612" style="display: block; margin: auto;" />

## Crear un histograma de valores ráster

Podemos explorar la distribución de valores contenidos dentro de nuestro ráster usando
la función `geom_histogram ()` que produce un histograma. Los histogramas suelen ser 
útiles para identificar valores atípicos o **outliers** y valores incorrectos en nuestros datos ráster.


~~~
ggplot() +
    geom_histogram(data = DSM_HARV_df, aes(HARV_dsmCrop))
~~~
{: .language-r}



~~~
`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
~~~
{: .output}

<img src="{{ site.baseurl }}/fig/rmd-01-view-raster-histogram-1.png" title="plot of chunk view-raster-histogram" alt="plot of chunk view-raster-histogram" width="612" style="display: block; margin: auto;" />

Observa que se genera un mensaje de advertencia cuando R crea el histograma.

`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

Esta advertencia es causada por una configuración predeterminada en `geom_histogram` que impone que
hay 30 contenedores (**bins**) para los datos. Podemos definir el número de contenedores
que queremos en el histograma usando el valor `bins` en la función` geom_histogram ()



~~~
ggplot() +
    geom_histogram(data = DSM_HARV_df, aes(HARV_dsmCrop), bins = 40)
~~~
{: .language-r}

<img src="{{ site.baseurl }}/fig/rmd-01-view-raster-histogram2-1.png" title="plot of chunk view-raster-histogram2" alt="plot of chunk view-raster-histogram2" width="612" style="display: block; margin: auto;" />

Observa que la forma de este histograma es similar a la anterior que se 
creó utilizando el valor predeterminado de 30 contenedores. La distribución de los
valores de elevación para nuestro `Modelo digital de superficie (DSM)` parece razonable. 
Es probable que no haya datos incorrectos en este ráster en particular.

> ## Challenge: Explore Raster Metadata
>
> Usa `GDALinfo()` lo siguiente acerca del archivo `NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_DSMhill.tif`:
>
> 1. ¿Este archivo tiene el mismo CRS que `DSM_HARV`?
> 2. ¿Cuál es el `NoDataValue`?
> 3. ¿Cuál es la resolución de los datos ráster?
> 4. ¿Qué tan grande sería un área de 5x5 píxeles en la superficie de la tierra?
> 5. ¿El archivo es un ráster con múltiples bandas o con una única banda?
>
> Observá: este archivo es un mapa de sombras. Aprenderemos sobre mapas de sombras en el episodio [Working with
> Multi-band Rasters in R]({{ site.baseurl }}/05-raster-multi-band-in-r/).
> >
> > ## Respuestas
> >
> > 
> > ~~~
> > GDALinfo("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_DSMhill.tif")
> > ~~~
> > {: .language-r}
> > 
> > 
> > 
> > ~~~
> > rows        1367 
> > columns     1697 
> > bands       1 
> > lower left origin.x        731453 
> > lower left origin.y        4712471 
> > res.x       1 
> > res.y       1 
> > ysign       -1 
> > oblique.x   0 
> > oblique.y   0 
> > driver      GTiff 
> > projection  +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs 
> > file        data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_DSMhill.tif 
> > apparent band summary:
> >    GDType hasNoDataValue NoDataValue blockSize1 blockSize2
> > 1 Float64           TRUE       -9999          1       1697
> > apparent band statistics:
> >         Bmin      Bmax     Bmean       Bsd
> > 1 -0.7136298 0.9999997 0.3125525 0.4812939
> > Metadata:
> > AREA_OR_POINT=Area 
> > ~~~
> > {: .output}
> > 1. ¿Si este archivo tiene el mismo CRS que DSM_HARV?  Si: UTM Zone 18, WGS84, metros.
> > 2. ¿Qué formato toma el `NoDataValues`?  -9999
> > 3. ¿La resolución de los datos ráster? 1x1
> > 4. ¿Qué tan grande sería un área de 5x5 píxeles? 5mx5m ¿Cómo? Se nos da la resolución de 1x1 y unidades en metros, por lo tanto una resolución de 5x5 significa 5x5m.
> > 5. ¿El archivo es un ráster de multiples bandas o de una única banda?  Una única banda.
> {: .solution}
{: .challenge}

> ## Más recursos
> * [Lee más acerca del paquete `raster` en R.](http://cran.r-project.org/package=raster)
{: .callout}

{% include links.md %}

